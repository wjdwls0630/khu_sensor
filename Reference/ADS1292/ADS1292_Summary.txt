
윈도우
Case 1) waitForReadyRead() 40 ~ 45
데이터 끊김없이 모두 읽음
데이터가 한칸 ~ 두칸 씩 밀려서 나옴 (Right shift)

Case 2) waitForReadyRead() >=50

데이터가 정상적으로 들어옴.
데이터가 잘 들어오다가 끊김 
다시 RDATAC를 입력하면 그 동안 안들어왔던 
데이터가 한번에 들어옴. 
-> C레벨에서 데이터 처리 가능 (데이터 규칙이 있음, ADS 데이터 시트)
그래프가 그려지다 한번에 그려지는 현상 발생
-> 사용자 입장에서 렉이 걸린 것처럼 보여질 수 있음
-> 나오다가 잠깐 멈췄다가 한번에 많이 그려짐

리눅스 
그냥 잘됨
다들 리눅스 까시길 
 

ecg 데이터 처리는 형태가 보여지는 방법이 있고, 
V 단위로 표시하는 방법 있음.

교수님이 V 단위로 표시하기를 원하시니 V로 표시하겠음

교수님이랑 이야기해본 결과

RA : Right Arm 
RL : Right Leg (usually the ground)
LA : Left Arm
LL : Left Leg

기본적으로 ADS1292(ECG)는 +,- 인풋의 차를 증폭하는 증폭기 (instrument diff amp 전회1 chap 2 참고)
즉 팔과 다리의 전기적 신호의 차이를 증폭 (gain은 레지스터 값으로 조정가능)

System Design 

Source -> Isolation -> Filtering(EMI Filter, HPF) -> Amplification -> Anti-alias filter(LPF) -> Digitization(24bit) -> Signal Processing

The reason why common mode rejection is not infinite
- Electric Field Interference -> Acm 낮춰야 하는 이유
(50Hz interference is common to measure electrodes, common mode signal)
- Magnetic induction (minimise coil area)
- Source impedance unbalance (if ecg contacts the skin(source) or use different electrodes and wire, impedance is going to be unbalanced. -> Acm increase)

이런 이유로 Acm =0 이 되어야하지만 
unwanted common mode signal 섞여 나옴  -> Noise

->데이터 시트에 의하면 Right Leg Drive (RLD DC Bias Circuit) section 참고
로 common-mode voltage can be controlled (레지스터 값 0x06으로 조정 가능)
 
하지만 이렇게 필터 처리를 해도 output noise는 존재 함 (eg muscle noise, clothes, etc...)
교수님이랑 상의 중인데 이 데이터를 원래 DSP 칩(하드웨어 연결)로 처리를 하는데 지금 없으니
씨 레벨에서 어떤 식으로 처리하는게 좋을지 의논 다시 해보자고 하심

ECG의 사용은 Ch2데이터를 통해서만 가능
ADS1292R Application
The ADS1292R channel 1 with respiration enabled mode cannot be used to acquire ECG signals. If the right arm
(RA) and left arm (LA) leads are intended to measure respiration and ECG signals, the two leads can be wired
into channel 1 for respiration and channel 2 for ECG signals, as shown in Figure 56.

TI 에서 제공하는 ADS1292 로 ECG 측정하는 전용 소프트웨어 프로그램 있는 것을 확인.

Ti 사이트에서 Serial communication 관련 ADS1292 문의 했더니 Windows7 로 바꾸라고 함. 
아직 Windows 10 전용 칩을 제공하지 않았다고 합니다.
->리눅스로 MPR121 까지 통일해서 운영체제 리눅스로 통일

->ECG Voltage 로 바꾸는 방법 (ADS1292 p.28 Data Format 참조)

(In our case, VREF = 2.42V)
INPUT SIGNAL, VIN (AINP – AINN)  IDEAL OUTPUT CODE(1)
       ≥ VREF                                  0x7FFFFF
+VREF / (2^23 – 1)                          0x000001
           0                                     0x000000
–VREF / (2^23 – 1)                          0xFFFFFF
≤ –VREF (2^23 / 2^23 – 1)                0x800000
(Excludes effects of noise, linearity, offset, and gain error.)

2^23-1 = 8388607_d = 0x7F
즉 인풋이 2.42 V 이상 ( 아무것도 안대고 있을 때 보통 0x7FFFFF 가 나옴)
이면 output 0x7FFFFF -2.42V면 output 0x800000

output range (0x800000 ~0x7FFFFF)

간단한 레인지로 바꿔서 쉽게 계산하기 위해 output에 0x800000를 XOR
( All bits will remain the same except for the MSB)

0x800000 ^ 0x800000 = 0x000000
0x7FFFFF ^ 0x800000 = 0xFFFFFFF 

-> output range changed (0x000000 ~ 0xFFFFFFF)

1bit = VREF/(2^23-1) = 0.2884865 uV

gain = 6 (default) (ADS1292 p.44 CH2SET gain setting 참조)
이면 

Volts = (output_code_changed - (2^23-1)-1(to correct for the single LSB error))*VREF/(2^23-1)/gain

원래 output code 가 0x800000면 (input diff volt = -2.42V) 면 결과 -0.4V
원래 output code 가 0x000000면 (input diff volt = 0V) 면 결과 0V

시간 축은 아직 공부를 안했음
근데 교수님이 보여주신 interval 간격에 따라 찍는 데이터 3주기 정도만 보여주면 될 것 같음



해야 할것

ads time - voltage그래프로 바꾸고 선 연결 제대로 하고 재연성 확인
mpr 121 보드위에 라이트 켜지도록 하기
캔버스(?)(자동차에 들어갈 통신 관련 공부하기)








